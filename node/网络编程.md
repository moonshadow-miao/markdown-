#网络编程
TCP服务在网络应用中十分常见,目前大多数的应用都是基于TCP搭建而成的.  
TCP全名为传输控制协议,在osi模型(由七层组成,分为物理层,数据链接层,网络层,传输层,会话层,表示层,应用层)中属于传输层协议.   
许多应用层协议都是基于TCP构建,典型的是HTTP,SMTP,IMAP等协议.  
![osi模型](http://oy99ekzhi.bkt.clouddn.com/18.jpg)   
###创建TCP服务端和客户端:
TCP服务端:  

	var net = require('net');
	var server = net.createServer();
	server.on('connection',function (socket) {
		// 新的连接
		socket.on('data', function (data) {
			socket.write("你好");
		});
		socket.on('end', function () {
			console.log('连接断开');
		});
		socket.write("hello world：\n");
	});
	server.listen(8124, function () {
		console.log('server bound');
	});

客户端:
	
	var net = require('net');
	var client = net.connect({port: 8124}, function () { //'connect' listener
		console.log('client connected');
		client.write('world!\r\n');
	});
	client.on('data', function (data) {
		console.log(data.toString());
		client.end();
	});
	client.on('end', function () {
		console.log('client disconnected');
	});
###TCP服务的事件
上述代码中,分为服务器事件和连接事件
####服务器事件
对于通过net.createServer()创建的服务器而言,是一个EventEmitter实例.有如下事件:  

- listen: 在调用server.listen()绑定端口后触发,server.listen(port,listener),通过listen()方法的第二个参数传入
- connection: 每个客户端连接到服务器时触发,通过net.createSever(),作为最后一个参数传递
- close: 当服务器关闭时触发,调用serve.close()后,服务器停止接收新的套接字连接,但是还会保持当前已有连接,待所有的连接都断开后,会触发该事件.
- error: 当服务器发生异常时,触发
####连接事件
服务端可以同时和多个客户端保持连接,对于每个连接而言,是典型的可写可读的stream对象.  
stream对象可以用于服务器和客户端之间的通信,既可以通过data事件从一端读取另一端发来的数据,也可以通过write()方法从一端向另一端发送数据.

- data: 当一端调用write()发送数据时,另一端会触发data事件
- end: 当连接中的任意一端发送了FIN数据(表示关闭连接)时触发
- connet: 事件用于客户端,当套接字和服务端连接成功时会被触发
- drain: 当任意一端调用write()发送数据,在当前这端会触发
- close: 当连接完全关闭时触发
- error: 异常发生时触发
- timeout: 当一定时间后不再活跃时触发,通知用户当前连接已经被闲置了

###UDP服务
UDP(用户数据包协议),与TCP协议一样属于网络传输层,不同之处在于,UDP不是面向连接.  
TCP经历三次握手后建立连接后,之后的会话都基于连接完成,此时客户端如果要与另一个TCP服务器通信,需要新建套接字完成连接.  
UDP中,一个套接字可以与多个UDP服务通信,不需要经历连接,但是容易丢包.
####创建UDP服务端和客户端
UDP套接字的一旦创建,既可以作为客户端发送数据,也可以作为服务器端接收数据:
	
	// UDP服务端
	var dgram = require('dgram');
	var socket = dgram.createSocket("udp4");
	server.on("message", function (msg, rinfo) {
		console.log("server got: " + msg + " from " + rinfo.address + ":" + rinfo.port);
	});
	server.on("listening", function () {
		var address = server.address();
		console.log("server listening " + address.address + ":" + address.port);
	});
	server.bind(41234);  // 绑定端口号,创建服务端

	// UDP客户端
	var dgram = require('dgram');
	var message = new Buffer("hello world");
	var client = dgram.createSocket("udp4");
	client.send(message, 0, message.length, 41234, "localhost", function(err, bytes) {
		client.close();
	});
	// 调用send方法发送消息

send()方法的参数,socket.send(buf,offset,length,port,address,[callback]),分别是要发送的Buffer,Buffer的偏移位置,Buffer的长度,目标端口,目标地址,发送完成的回调.  

书签:P173


	



