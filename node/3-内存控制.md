#内存控制
###v8的内存限制
node中通过javascript使用内存(64位系统约为1.4GB,32位系统下约为0.7GB). 造成这个问题的主要原因是node基于v8构建的,v8的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余,足以胜任前端页面的所有需求.
###内存管理模型
node程序运行中,进程占用的所有内存称为常驻内存,由以下部分组成:  
![v8内存模型](http://oy99ekzhi.bkt.clouddn.com/10.png)  
堆外内存:不通过v8分配,也不受v8管理,buffer对象的数据就存放于此
###v8的对象分配
在v8中,所有的js对象都是通过堆进行分配的,node中process.memoryUsage()方法返回三个属性,heapTotal和heapUsed是v8的堆内存使用情况,前者是申请到的堆内存,后者是当前使用的量.  
当我们在代码中声明变量并赋值是,所使用对象的内存就分配在堆中,如果已申请的堆空闲内存不够分配新的对象,将会继续申请堆内存,直到超过限制.  
node在启动是可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小,如: 

	node --max-old-space-size=1700 test.js // 单位为MB,设置老生代的内存空间
	// 或者
	node --max-new-space-size=1024 test.js // 单位为KB
上述参数在v8初始化生效,不能动态改变.
##v8的垃圾回收机制
### 1.v8主要的垃圾回收算法
v8的垃圾回收策略主要基于分代式垃圾回收机制. 实际的应用中,对象的生存周期长短不一,按照对象的存活时间将垃圾进行不同的分代,然后分别对不同分代的内存实施高效的算法.  
v8中,主要将内存分为新生代和老生代,新生代中的对象为存活时间较短的对象(未经历垃圾回收或仅经历过一次),老生代的对象为存活时间较长或常住内存的对象(经历过一次或更多次垃圾回收). v8堆的整体大小就是新生代所用的内存空间加上老生代的内存空间. 
![堆内存分布图](http://oy99ekzhi.bkt.clouddn.com/12.png)
####scavenge 算法(新生代)
采用复制的方式实现垃圾回收,将新生代堆内存一分为二,每一部分空间称为semispace,在两个semispace空间中,只有一个处于使用中(称为form空间),另一个处于闲置状态(称为to空间).   
当分配对象时,先在form空间总分配,开始进行垃圾回收的时候,会检查from控件的存活对象,这些个存活对象将被复制到to空间中,非存活对象占用的空间将会被释放.完成复制后,from空间和to空间对换(原to空间变成from空间,原form空间被释放变成to空间)  
有两种情况不会讲对象复制到to空间,而是直接晋升到老年代:  

- 对象此前已经经历过一次新生代垃圾回收
- to空间已经使用了25%,

因为Scavenge**只复制活着的对象** ，而根据统计学指导，新生代中大多数对象寿命都不长，长期存活对象少，则需要复制的对象相对来说很少，因此总体来说，新生代使用Scavenge算法的效率非常高。且由于Scavenge是依次连续复制，所以To空间永远不会存在内存碎片。  
不过由于Scavenge会将空间对半划分，所以此算法的空间利用率较低。  
![新生代对象晋升](http://oy99ekzhi.bkt.clouddn.com/11.png)
###mark-sweep和mark-compact算法(老生代)
mark-sweep:标记清除,在标记阶段遍历堆中所有的对象,标记活着的对象,在随后的清除阶段, **只清除没有被标记的对象(死亡对象)** . 活对象在新生代中只占较小部分,死对象在老生代中只占较小部分,这是两种回收方式能高效处理的原因.  
mark-sweep最大的问题是在进行一次标记清除回收以后,内存空间出现不连续的状态,这种内存碎片会对后续的内存分配造成问题.因此mark-compact(标记整理)提出来,在mark-sweep的基础上演变而来,他们的差别在于对象在标记死亡后,优化整理的过程,讲活着的对象往一端移动,移动完成后直接清理掉边界外的内存.  
![mark-compact完成标记并移动存活对象示意图](http://oy99ekzhi.bkt.clouddn.com/13.png)  
白色格子是存活对象,深色格子是死亡对象,浅色格子是存活对象移动后留下的空洞.  
由于mark-compact需要移动对象,执行速度较慢,所以**v8主要使用mark-sweep,在空间不足以对从新生代中晋升过来的对象进行分配时,才会使用mark-compact** .
###停顿处理
垃圾回收的三种算法执行时,都会将应用逻辑暂停下来(全停顿),执行完毕后恢复.新生代的存活对象少,全停顿的影响不大,但是对老生代中产生的停顿需要改善. v8在标记阶段入手,改用增量标记(把一次性标记完成任务拆分成小'步进',每做完一个'步进',js应用逻辑执行一会,相互交替执行,直到标记全部完成),如图:  
![增量标记示意图](http://oy99ekzhi.bkt.clouddn.com/14.png)
###查看垃圾回收日志
查看垃圾回收日志的主要方式是在启动是添加 --trace_gc 参数. 在进行垃圾回收,将会从标注输出中打印垃圾回收日志信息.
##高效的使用内存
###变量的主动释放
如果变量是全局变量(在node中,不通过var声明或者定义在global变量上),全局作用域需要到进程退出才能释放,所以全局变量常驻内存(老生代中),可以通过delete操作删除,或者将变量赋值为null,undefined.
###闭包
在js中,实现外包作用域访问内部作用域中变量的方法称为闭包.
###内存泄露
实质:应当回收的对象出现意外而没有被回收,变成了常驻在老生代中的对象.  
通常,造成内存泄露的原因有:  

- 缓存
- 队列消费不及时
- 作用域未释放

在node中,一个对象被当做缓存来使用,意味着常驻在老生代中,缓存中存储的键越多,长期存活的对象也就越多.

	var cache = {};
	var get = function (key) {
		if (cache[key]) {
			return cache[key];
		} else {
		// get from otherwise
		}
	};
	var set = function (key, value) {
		cache[key] = value;
	};


