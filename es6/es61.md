###暂时性死区
	var tmp = 123;
	if (true) {
  		tmp = 'abc'; // ReferenceError
  		let tmp = '50';
	}  
只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响.ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“暂时性死区”.     
处于暂时性死区时候,typeof运行也会会抛出一个ReferenceError错误.但是一个变量根本没有被声明,typeof的结果是undefined,不会报错.  
例子:  

	例子一
	function bar(x = y, y = 2) {         // x=y 时报错,y此时还没声明 
  		return [x, y];
	}
	bar(); // 报错
	例子二:
	function f() { console.log('I am outside!'); }
	(function () {
  		if (false) {
    		// 重复声明一次函数f
    		function f() { console.log('I am inside!'); }   // 会
  		}
  	console.log(f)      // undefined
	}());